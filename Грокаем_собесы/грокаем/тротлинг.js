function throttle(callback, delay) {
  let isWaiting = false; // Переменная для отслеживания состояния задержки
  let savedArgs = null;  // Переменная для сохранения аргументов, если вызов произошел во время задержки
  let savedThis = null;  // Переменная для сохранения контекста вызова (this), если вызов произошел во время задержки

  function wrapper(...args) {
    if (isWaiting) {
      // Если уже идет задержка, сохраняем аргументы и контекст вызова
      savedArgs = args;
      savedThis = this;
      return; // Прерываем выполнение, так как нужно дождаться завершения таймера
    }

    // Если задержки нет, выполняем основную функцию с переданными аргументами
    callback.apply(this, args);

    // Устанавливаем флаг, что теперь мы ждем
    isWaiting = true;

    // Запускаем таймер на заданный период задержки
    setTimeout(() => {
      isWaiting = false; // Таймер закончился, можно снова вызывать функцию

      // Проверяем, были ли вызовы во время задержки
      if (savedThis) {
        // Если были сохраненные аргументы и контекст, вызываем функцию еще раз с ними
        wrapper.apply(savedThis, savedArgs);

        // Очищаем сохраненные аргументы и контекст
        savedThis = null;
        savedArgs = null;
      }
    }, delay);
  }

  return wrapper; // Возвращаем функцию-обертку для использования
}
