// 1) В цепочках ДНК символы «А» и «Т» стоят напротив друг друга, как «С» и «G». Ваша функция получает одну сторону ДНК и возвращает другую, противоположную сторону
//
// То есть:
//
// A всегда меняется на T
// T на А
// С на G
// G на С
// ______
// Вход:
// АААА
//
// Выход:
// TTTT
//
// __
// Вход:
// АTTGC
//
// Выход:
// TAACG
//
// __
// Вход:
// GTAT
//
// Выход:
// CATA

// 1 способ:
const getStr = (str) => {
  const obj = {A: 'T', C: 'G', G: 'C', T: 'A'}

  return str.split('').map((char) => obj[char]).join('') // изначально тут буква "А", он получает значение из obj["А"] === const obj = {A: 'T'}
  // на след.итерации остальные буквы также делает
  // такая запись: obj[char] - значит получает не своиство а значение
 // с "ифами" алгоритмически дольше решается задача

  console.log(str.split('')) // [ 'А', 'А', 'А', 'А' ]

}

console.log(getStr('АААА')) // TTTT
console.log(getStr('АCAC')) // TGTG

/*
- когда наити количество (посчитать) или заменить одно на другое (есть структуры которые надо сопоставить друг с другом) использовать
 словарик (объекты) - быстрее работа будет идти
- приводим строку к массиву и пробегаемся по нему и смотрим находиться ли он тут: const  obj = {A: 'T', C: 'G', G: 'C', T: 'A'} если
 находится то его оправляем в наш новый массив - делаем новый массив строкой и вернем ее из функции
 */


