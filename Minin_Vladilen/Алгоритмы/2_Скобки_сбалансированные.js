/*
### Сбалансированные скобки
Напишите функцию, которая проверит строку на сбалансированность скобок: `{}, (), []`. Вернуть `true` если они сбалансированы, иначе `false`.
Для каждой открытой скобки должна быть закрывающаяся скобка
 */
function isBalanced(string) {
    const start = "{[(";
    const end = "}])";

    const map = { // сопоставление скобок проверяем - карта словарь
        "}": "{",
        "]": "[",
        ")": "(",
    };

    const queue = []; // стэк

    for (let i = 0; i < string.length; i++) {
        const current = string[i]; // для удобства

        // итерируемся по строчке и проверяем текущии символ относиться ли вообще к строчкам start и end
        if (start.includes(current)) { // если start включает в себя какую-либо из закрывающих строчек - тогда запомним этот символ и занесем
            // его в очередь queue
            queue.push(current);
            // проверяем а есть ли в нашем масиве очереди queue открывающаяся скобочка которая соответствует
        } else if (end.includes(current)) {
            // этому символу current
            // pop - удаляем последний элемент масива и его возвращает - в last будет хранится открывающаяся скобка
            const last = queue.pop();
            // скобка из масива queue, и если эта открывающаяся скобка соответствует этому current, который закрывающаяся скобка то все
            // хорошо, но если не соответствует тогда вернем false -- делаем карту которая будет показывать их соответствие last и current
            if (map[current] !== last) {
                return false;
            }
        }
    }

    return !queue.length; // тут будет ноль - делаем отрицание и вернем true
}

/*
- last -- открывающаяся скобка
- map[current] -- закрывающаяся
 */

console.log(isBalanced("(x + y) - (4)")); // -> true
console.log(isBalanced("(((10 ) ()) ((?)(:)))")); // -> true
console.log(isBalanced("[{()}]")); // -> true
console.log(isBalanced("(50)(")); // -> false
console.log(isBalanced("[{]}")); // -> false -- тут неправильный порядок скобок
