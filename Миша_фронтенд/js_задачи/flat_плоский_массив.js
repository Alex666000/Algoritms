// Выровнять глубоко вложенный массив без использования "Array.flat" на n-ое кол-во уровней
// Максимально-возможный уровень вложенности - 1000
// 4 https://www.youtube.com/watch?v=T_zWJYVZJRU&list=PLIpOJPtzllpM-mzxXSF4npTEl7AE3dsa7&index=9
/**
 * @param {any[]} arr
 * @param {number} depth
 * @return {any[]}
 */

var flat = function (arr, n) {
  if (!n) return arr;
  const result = [];

  arr.forEach((el) => {
    if (Array.isArray(el)) {
      result.push(...flat(el, n - 1));
    } else {
      result.push(el);
    }
  });

  return result;
};

const inputArray = [1, [2, [3, [4, 5]]], [6, 7], 8];

console.log(flat(inputArray, 1)); // Глубина развёртки: 1
console.log(flat(inputArray, 2)); // Глубина развёртки: 2
console.log(flat(inputArray, 3)); // Глубина развёртки: 3
console.log(flat(inputArray, 0)); // Глубина развёртки: 0

/*
 Оно рекурсивно проходит по массиву, проверяя, является ли элемент вложенным массивом, и в таком случае вызывает функцию flat снова с уменьшением значения n (глубины). Когда глубина достигает 0 или элемент не является массивом, он добавляется в результирующий массив.
Однако стоит отметить несколько моментов:
Условие if (!n) return arr;: Это означает, что если глубина n равна нулю, то массив возвращается как есть, без дальнейшей обработки. Это правильное поведение для ограничения глубины развёртки.
Рекурсия: Функция использует рекурсию для обработки вложенных массивов. Поскольку условие уменьшает глубину n, вероятность переполнения стека вызовов мала (но для глубоко вложенных массивов с большим n это всё же может произойти).
Производительность: Вызов result.push(...flat(el, n - 1)) с оператором спред может быть менее эффективным для массивов с большим количеством вложенных уровней.
 */
// ----------------------------------
// Без рекурсии:
const flatten = (...args) => {
  const queue = [...args]; // Используем очередь вместо стека
  const resultArr = [];

  while (queue.length) {
    const item = queue.shift(); // Берём первый элемент из очереди

    if (Array.isArray(item)) {
      // Если элемент - массив, добавляем его элементы в конец очереди
      queue.push(...item);
    } else {
      // Если элемент не массив, добавляем его в результат
      resultArr.push(item);
    }
  }

  return resultArr; // Здесь не нужно переворачивать результат
};

// Пример работы
console.log(flatten(-1, [2, [[3]]], 4, 5, [6, [7]]));
// Вывод: [-1, 2, 3, 4, 5, 6, 7]


// Пример работы
console.log(flatten(-1, [2, [[3]]], 4, 5, [6, [7]]));
// Вывод: [-1, 2, 3, 4, 5, 6, 7]

// 3 плоскийй массив:
// 1 способ - в лоб рекурсией:
const flatten = (...args) => {
  const result = []

  args.forEach((item) => {
    if (Array.isArray(item)) {
      // тк flatten возвращает массив (то можем деструктурировать функцию) то через запятую можем делать
      // пушить несколько элементов
      // если массив выполнение текущей функции flatten останавливается и происходит вызов от внутренних параметров:
      // flatten(...item) - соответственно вызывается функция  flatten([2, [[3]]]) потом flatten([3]) и тд...
      result.push(...flatten(...item))
    } else {
      result.push(item)
    }
  })

  return result
}

// 2 способ - reduce() - тк возвращаем массив редюсом удобнее
const flatten = (...args) => {
  return args.reduce((acc, item) => {
    if (Array.isArray(item)) {
      acc.push(...flatten(...item))
    } else {
      acc.push(item)
    }
    return acc
  }, [])
}

console.log(flatten(-1, [2, [[3]]], 4, 5, [6, [7]]));

