// Выровнять глубоко вложенный массив без использования "Array.flat" на n-ое кол-во уровней
// Максимально-возможный уровень вложенности - 1000
// 4 https://www.youtube.com/watch?v=T_zWJYVZJRU&list=PLIpOJPtzllpM-mzxXSF4npTEl7AE3dsa7&index=9
/**
 * @param {any[]} arr
 * @param {number} depth
 * @return {any[]}
 */

var flat = function (arr, n) {
  if (!n) return arr;
    const result = [];

  arr.forEach((el) => {
    if (Array.isArray(el)) {
      result.push(...flat(el, n - 1));
    } else {
      result.push(el);
    }
  });

  return result;
};

const inputArray = [1, [2, [3, [4, 5]]], [6, 7], 8];

console.log(flat(inputArray, 1)); // Глубина развёртки: 1
console.log(flat(inputArray, 2)); // Глубина развёртки: 2
console.log(flat(inputArray, 3)); // Глубина развёртки: 3
console.log(flat(inputArray, 0)); // Глубина развёртки: 0

/*
 Оно рекурсивно проходит по массиву, проверяя, является ли элемент вложенным массивом, и в таком случае вызывает функцию flat снова с уменьшением значения n (глубины). Когда глубина достигает 0 или элемент не является массивом, он добавляется в результирующий массив.
Однако стоит отметить несколько моментов:
Условие if (!n) return arr;: Это означает, что если глубина n равна нулю, то массив возвращается как есть, без дальнейшей обработки. Это правильное поведение для ограничения глубины развёртки.
Рекурсия: Функция использует рекурсию для обработки вложенных массивов. Поскольку условие уменьшает глубину n, вероятность переполнения стека вызовов мала (но для глубоко вложенных массивов с большим n это всё же может произойти).
Производительность: Вызов result.push(...flat(el, n - 1)) с оператором спред может быть менее эффективным для массивов с большим количеством вложенных уровней.
 */

