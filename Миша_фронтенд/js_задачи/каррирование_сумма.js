// 1 - легкое каррирование:
function sum(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

// Пример использования
console.log(sum(1)(2)(3)); // 6


// любые случаи каррирования:
function sum(a, b, c) {
  return a + b + c
}

function multi(a, b, c) {
  return a * b * c
}

function curry(fn) {
  return function curried(...args) { // первый уровень вызова ()
    // если количество аргументов переданных в функцию >= чем сама функция требует этих аргуметов, например 3 аргумента === 3
    if (args.length >= fn.length) {
      return fn.apply(this, args) // возвращаем значение + чтобы в будущем контекст не потерялся
    }


    return curried.bind(this, ...args)
    // иначе снова вернуть функцию (вызвать ее надо раз не попали в 1 условие)
    // возвращаем функцию curried после вызова первых (), но уже с накопленными аргументами - переходим к след. скобкам () и тд ()
    //   return function test(...newArgs) {  // второй уровень вызова () - тк вернули функцию можем еще раз вызвать
    //     return curried.apply(this, [...args, ...newArgs]) // берем предыдущие аргументы из замыкания + новые (dct d vfccbd)
    //   }
  }
}

const curriedSum = curry(sum) // создаем обертку над функцией, которая вернет "каррированную" функцию, которую вызываем с разными () () и тд
// const curriedMulti = curry(multi())

console.log(curriedSum(2))
console.log(curriedSum(2, 3, 4)) // => 9  -- сценарий 1
console.log(curriedSum(2)(3)(4)) // => 9  -- сценарий 4
console.log(curriedSum(2, 3)(4))  // => 9  -- сценарий 3

/*
- каррирование - пмогает отложить аргументы, когда пришли не все аргументы и мы хотим с несколькими аргументами вызвать функцию и потом
 довызывать с аргументами
- делаем универсальную обертку curry куда передаем функцию - curry при вызове вернет функцию
- из функции curry возвращаем функцию которую потом сможем еще раз вызвать
- 1 проверяем достаточно нам уже аргументов или нет?
 */
