const remapData = (dataArray) => {
  return dataArray.reduce((acc, currentArr) => {
    const [product, ...people] = currentArr; // Первый элемент — товар, остальные — люди

    people.forEach(person => {
      if (!acc[person]) {
        acc[person] = []; // Если человека нет в объекте, создаем массив
      }
      acc[person].push(product); // Добавляем товар в массив
    });

    return acc;
  }, {});
};

// У вас есть массив массивов dataArray.
// Каждый вложенный массив описывает товар и людей, связанных с этим товаром:
// Первый элемент — это название товара.
// Остальные элементы — это имена людей, которые связаны с этим товаром.
console.log(
  remapData([
    ['Помидоры', 'Аня', 'Женя'], // {} item
    ['Огурцы', 'Женя', 'Аня'], // item
    ['Рис', 'Аня', 'Саша'], // item
    ['Лосось', 'Иван'], // item
  ])
);
// Что нужно получить:
// Необходимо создать объект: { }, где:
// Ключами будут имена людей (например, 'Аня', 'Женя', 'Иван').
// Значениями для каждого ключа будет массив товаров, связанных с этим человеком.
// Пример результата (Преобразовать массив - в обьект совпадении персон с товарами):

// {
//   'Аня': ['Помидоры', 'Огурцы', 'Рис'],
//   'Женя': ['Помидоры', 'Огурцы'],
//   'Иван': ['Лосось'],
//   'Саша': ['Рис']
// }
// ====================================================================================================================================
// Задача: 2
// У вас есть массив пользователей.Нужно преобразовать его в объект,
// где ключами будут ID пользователей, а значениями — их данные.

const users = [
  { id: 1, name: 'Аня', age: 25 },
  { id: 2, name: 'Женя', age: 30 },
  { id: 3, name: 'Саша', age: 28 },
];

// Результат:
// {
// 1: { id: 1, name: 'Аня', age: 25 },
// 2: { id: 2, name: 'Женя', age: 30 },
// 3: { id: 3, name: 'Саша', age: 28 }
// }

// Решение:
// 1 способ:
const changer = (objArray) => {
  return objArray.reduce((acc, currObj) => {
    if (!acc[currObj.id]) {
      acc[currObj.id] = {}
    }

    acc[currObj.id] = { id: currObj.id, name: currObj.name, age: currObj.age }

    return acc
  }, {}) // const acc = {} end: const acc = { 1: { id: 1, name: 'Аня', age: 25 }, }
}

console.log(changer(users))

// 2 способ: через деструктуризацию
const changer = (objArray) => {
  return objArray.reduce((acc, currObj) => {
    const { id, name, age } = currObj; // Деструктурируем свойства объекта

    if (!acc[id]) {
      acc[id] = {}
    }

    acc[id] = { id, name, age } // Используем деструктурированные значения

    return acc;
  }, {}); // Инициализация объекта
}

console.log(changer(users));
// ====================================================================================================================================
// Задача 3: Подсчет повторений
// У вас есть массив строк, например, имена, и вам нужно посчитать, сколько раз каждое имя встречается.
//
// Исходный массив:

// const names = ['Аня', 'Женя', 'Аня', 'Саша', 'Женя', 'Женя'];
// Результат:

// {
//     'Аня': 2,
//     'Женя': 3,
//     'Саша': 1
// }
// ====================================================================================================================================
// Задача: 4
// 1) Написать функцию, принимающую строку в качестве аргумента и возвращающую количество гласных, которые содержатся в строке.
// Гласными являются «a», «e», «i», «o», «u».
//
// Например:
//   Вход: morning
// Выход: 2
//
// 2) Определить сколько раз каждый элемент встречается в массиве.
//
//   Вход:
// ['kiwi', 'apple', 'kiwi', 'orange', 'kiwi', 'apple'];
//
// Выход: {kiwi: 3, apple: 2, orange: 1}

// 1 Решение:  ----------------------------------------

/* reduce */
// const countElement = (array) => {
//   // всегда возвращаем reduce (возвращает любой тип данных)
//   return array.reduce((obj, item) => {
//     if (obj[item]) {
//       obj[item] = obj[item] + 1
//     } else {
//       obj[item] = 1
//     }
//
//     return obj // // Возвращаем "аккумулятор" для следующей итерации
//   }, {})
//
//   // Выход: {kiwi: 3, apple: 2, orange: 1}
// }
//
// console.log(countElement(['kiwi', 'apple', 'kiwi', 'orange', 'kiwi', 'apple']))


// 1 способ:
/* const countElem = (array) => {
  const initObj = {}

  array.forEach((item) => {
    if (initObj[item]) {
      initObj[item] = initObj[item] + 1
    } else {
      initObj[item] = 1
    }
  })

  return initObj

}
// Выход: {kiwi: 3, apple: 2, orange: 1}

console.log(countElem(['kiwi', 'apple', 'kiwi', 'orange', 'kiwi', 'apple'])) */


// 2 Решение: --------------------------------------
/*const glasses = (str) => {
  const initArr = ['a', 'e', 'i', 'o', 'u'] // Гласными являются «a», «e», «i», «o», «u».
  const res = []

  initArr.forEach((item) => {
   if (str.split('').includes(item)) {
     res.push(item)
   }
  })

  return res.length  // возвращающую количество гласных, которые содержатся в строке
}
console.log(glasses('morning'))*/
// ====================================================================================================================================
// Задача: 5
// написать функцию, либо последовательность операций, которая вернет результат следующих условий
// результат есть строка из сконкатенированных value элементов коллекции, расположенных в обратном порядке символов,
// результат собирается только из неиспорченных записей и конкатенируется в порядке возрастания order
// результат не содержит одинаковых символов
// https://www.youtube.com/watch?v=DEP_9rrIVWk&list=PLIpOJPtzllpM-mzxXSF4npTEl7AE3dsa7&index=13

const input = [
  { value: 'abcd', order: 4, expired: false },
  { value: 'qwer', order: 2, expired: true },
  { value: 'xyz1', order: 1, expired: false },
  { value: 'abx2', order: 3, expired: false },
];

// Решение:




















// ====================================================================================================================================
// Задача: 6




































