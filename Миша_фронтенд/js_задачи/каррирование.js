// Задачи с собеса:
const curriedSum = (num1) => (num2) => (num3) => () => num1 + num2 + num3

console.log(curriedSum(2)(1)(4))

// чтобы функция обрабатывала лишние ():
const curriedSum = (num1) => {
  return (num2) => {
    return (num3) => {
      return (extraCall) => { // Дополнительная проверка для вызова с лишними скобками
        if (typeof extraCall === 'undefined') {
          return num1 + num2 + num3; // Вернуть результат, если `extraCall` не передан
        }
        throw new Error('Too many arguments!');
      };
    };
  };
};
console.log(curriedSum(2)(1)(4)()); // Вывод: 7

// ========================================================================================================================================
// Дано:
let nums = [1, 2, 3, 4, 23, 2]

// console.log(currledSum(3)(4)) // Должно быть 7

// Решение: каррирование возвращает функцию с цепочкой вызовов:
/*const currledSum = (x) => {
  return (c) => c + x
}
console.log(currledSum(3)(4))*/

/*
 - Каррирование (currying) — это техника преобразования функции, принимающей несколько аргументов, в последовательность функций, каждая из
которых принимает "один аргумент".

Пример:
// 1)  Исходная функция, принимающая 2 аргумента
function add(a, b) {
  return a + b;
}

// Каррированная версия функции - каждая из которых принимает по 1 аргументу
function curriedAdd(a) {
  return function (b) {
    return a + b;
  };
}

// Использование
console.log(curriedAdd(5)(3)); // 8
---------------------------------------
Когда 3 числа:
2) const curried = (a) => {
    return(b) => {
        return (c) => {
            return a + b + c
        }
    }
}

console.log(curried(3)(4)(4)) // Должно быть 11
-----------------------------------------------
3) Каррирование для произвольного числа аргументов:
Задача: Напиши функцию sum, которая позволяет последовательно добавлять числа и возвращать результат только после вызова без аргументов.
Тебе нужно сохранить промежуточный результат (например, через замыкание).
Когда функция вызвана без аргументов, она должна вернуть накопленное значение.
Реализуй логику вызовов с помощью вложенных функций.

function sum(acc = 0) { // acc: для хранения промежуточной суммы
  return (num) => { // возвращаем новую функцию с аргументом num
    if (num === undefined) {
        return acc; // Если нет аргументов, возвращаем накопленное значение - текущую сумму
    }
    return sum(acc + num); // Возвращаем новую функцию с обновленным аккумулятором
  };
}

// Примеры использования
console.log(sum(1)(2)(3)()); // 6
console.log(sum(5)(10)(15)(20)()); // 50
console.log(sum()); // 0

Объяснение:
Инициализация:
Функция sum принимает один аргумент acc, который инициализирован значением 0 по умолчанию.
Этот аргумент используется для хранения промежуточной суммы.
Рекурсивное замыкание:
Внутри функции возвращается новая функция, которая принимает следующий аргумент (num).
Если num равен undefined (вызов без аргументов), возвращается текущая сумма (acc).
Если num существует, вызов sum(acc + num) создает новое замыкание с обновленной суммой.
Остановка:
Выражение sum() завершает цепочку вызовов и возвращает итоговую сумму.


============================================================================================================================================
Объяснение:
Функция "curriedAdd" принимает один аргумент "a" и возвращает новую функцию.
Внутренняя функция принимает второй аргумент "b" и возвращает их сумму "a + b".
Как это работает:

Вызов "curriedAdd(5)" создает функцию, "запоминая" значение a = 5 - замкнулось значение 5 - "классика замыкания"
Вызов этой функции с аргументом (3) завершает вычисление, возвращая 5 + 3 = 8.
 */
// ========================================================================================================================================
// Своя функция карирования: "любые случаи каррирования":
/*
function curry(fn) {
  return function curried(...args) { // первый уровень вызова ()
    // если количество аргументов переданных в функцию >= чем сама функция требует этих аргуметов, например 3 аргумента === 3
    if (args.length >= fn.length) {
      return fn.apply(this, args) // возвращаем значение + чтобы в будущем контекст не потерялся
    }


    return curried.bind(this, ...args)
    // иначе снова вернуть функцию (вызвать ее надо раз не попали в 1 условие)
    // возвращаем функцию curried после вызова первых (), но уже с накопленными аргументами - переходим к след. скобкам () и тд ()
    //   return function test(...newArgs) {  // второй уровень вызова () - тк вернули функцию можем еще раз вызвать
    //     return curried.apply(this, [...args, ...newArgs]) // берем предыдущие аргументы из замыкания + новые (dct d vfccbd)
    //   }
  }
}

const curriedSum = curry(sum) // создаем обертку над функцией, которая вернет "каррированную" функцию, которую вызываем с разными () () и тд
// const curriedMulti = curry(multi())

console.log(curriedSum(2))
console.log(curriedSum(2, 3, 4)) // => 9  -- сценарий 1
console.log(curriedSum(2)(3)(4)) // => 9  -- сценарий 4
console.log(curriedSum(2, 3)(4))  // => 9  -- сценарий 3
*/

/*
- каррирование - пмогает отложить аргументы, когда пришли не все аргументы и мы хотим с несколькими аргументами вызвать функцию и потом
 довызывать с аргументами
- делаем универсальную обертку curry куда передаем функцию - curry при вызове вернет функцию
- из функции curry возвращаем функцию которую потом сможем еще раз вызвать
- 1 проверяем достаточно нам уже аргументов или нет?
 */

