/*
--> ПРАВИЛА "EVENT_LOOP":
- отделяем код строчками чтобы глазу понятнее было
- пишем коммент "//" и пимем ответ: // 1 6 3 5 2.........
- setTimeout внутри "микротаски" выполнится после обычнного таимаута
- код после await выполниться в последнюю очередь (область видимости фигурные скобки "{ }" )
- если промисс "резолвиться" внутри setTimeout - то "микротаска" выполнится после макротаски
- то что внутри: resolve() сихронно работает, но если resolve() внутри setTimeout-а тогда становится микротаской - зн.выполнится после
 синхронного кода
- синхр.код выполнится первый не зависимо от уровня вложенноси, микротаски идут по области видимости или по-другому: по очередности
добавления микротасок в очередь
- макротаски: setTimeout_ы выполняются в очередности добавления в очередь если не установлена задержка.
setTimeout с нулевой задержкой выполняется раньше чем с delay задержкой
- setTimeout выполнится быстрее тот который просто (даже если у него > delay), а не тот что внутри then() находится (даже если у того
 который в then - delay меньше или "нулевая")
 */
const func1 = async () => {
  console.log('1', '?');

  setTimeout(() => console.log('2', '?'), 0);

  Promise.resolve().then(() => console.log('3', '?'));

  const func2 = async () => {
    setTimeout(() => console.log('4', '?'), 1);
    console.log('5', '?');
    Promise.resolve().then(() =>
      setTimeout(() => console.log('6', '?'), 0)
    );

    const importValue = new Promise((res) => {
      console.log('7', '?');
      Promise.resolve().then(() => console.log('8', '?'));

      setTimeout(() => {
        res();
      }, 5);
    });

    await importValue;

    console.log('9', '?');
  };

  Promise.resolve().then(() => console.log('10', '?'));

  await func2();

  console.log('11', '?');
};

func1();

console.log('12', '?');

/* Ответ: // синхр: 1 5 7 12 / микро: 3 10 8 /макро: 2 4 6 9 11
синхронный код выполняется всюду - не зависимо от области видимости
3 и 10 тк из глобальной области сначала не прыгаем в функции (код func1() выполняется при вызове а не определяетс как внутри др
функций) + после await строка не выполниться пока промис не вернется
4 первее 6 тк 6 вложена макро внутрь микро === макро */

// --------- Задача:
// 2 TASK: EVENT LOOP (1 6 3 2 7 8 ) - 7 первее 8 тк 7 попала в очередь макротасок быстрее ("зарегистрировалась")
console.log(1);
setTimeout(() => console.log(2));
Promise.reject(3).catch(console.log);
Promise.resolve(5).then(() => setTimeout(() => console.log(8),0))
console.log(6);
setTimeout(() => console.log(7),0);

// 1 6 3 2 7 8

// -----------------------------------------------------------------------------------------------------------------------------------
const promise = new Promise((resolve) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});

promise.then((res) => {
  console.log(res);
});

console.log(4);
// -----------------------------------------------------------------------------------------------------------------------------------
// 1 ЗАДАЧА : ---------------------------------------------------------------
const promise = new Promise((resolve) => {
  console.log(1);
  setTimeout(() => {
    console.log('timerStart');
    resolve('success'); // синхронен но внутри setTimeout работает как "микротаска"
    console.log('timerEnd');
  }, 0);
  console.log(2);
});

promise.then((res) => {
  console.log(res);
  console.log(4);
});

console.log(3);
// 1 2 3 timerStart timerEnd success 4
// когда промисс зарезолвится только потом отработает then
// -----------------------------------------------------------------------------------------------------------------------------------
// 3 задача:
console.log(1);
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve(console.log(5)).then(() => console.log(6));
setTimeout(() => console.log(7));
console.log(8);
/*
1 5 8 3 6 2 7 4 - макротаска в микротаске выполнится самои последнеи после остальных макротасок
 */
// -------------------------------------------------------------------------------------------------------------------------------------
// 4 задача:
const run = () => {
  setTimeout(() => {
    console.log('timeOut');
  }, 0);
};

console.log(1);

new Promise((resolve) => {
  console.log('Promise');
  setTimeout(() => {
    console.log('777');
    resolve();
  }, 0);
})
  .then(() => {
    console.log('then1');
  })
  .then(() => {
    console.log('then2');
  });

console.log(4);

setTimeout(() => {
  console.log('timeOut2');
}, 0);

// // 1 Promise 4 timeOut 777 then1 then2 timeOut2
// ---------------------------------------------------------------------------------------------------------------------------------------
console.log(1);
setTimeout(() => console.log(2));
Promise.reject(3).catch(console.log); // микрозадача
Promise.resolve(5).then(() => setTimeout(() => console.log(8), 0)); // макро внутри микро
console.log(6);
setTimeout(() => console.log(7), 0);

// 1 6 3 2 7 8
// Макрозадачи выполняются в том порядке, в котором они были добавлены в очередь.
// Макрозадача для console.log(7) была добавлена до того, как в микрозадаче добавилась макрозадача для console.log(8).
// ----------------------------------------------------------------------------------------------------------------------------------------
console.log(1);

setTimeout(() => console.log(2));

Promise.resolve().then(() => console.log(3));

Promise.resolve().then(() => setTimeout(() => console.log(4)));

Promise.resolve().then(() => console.log(5));

setTimeout(() => console.log(6));

console.log(7);
// Ответ: 1 7 3 5 2 6 4
/*
макро-в микро: Promise.resolve().then(() => setTimeout(() => console.log(4))) - в конце
 */
// ---------------------------------------------------------------------


// -----------------------------------------------------------------------------------------------------------------------------------


// -----------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------


// -----------------------------------------------------------------------------------------------------------------------------------

