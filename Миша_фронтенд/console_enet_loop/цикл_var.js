// Переменная i объявлена с помощью var, что делает её область видимости "общей-глобальной" для всех итераций цикла.
// Все вызовы setTimeout используют одно и то же глобальное значение i, и это значение обновляется как синхронный код перед каждой итерации
// Тут работает все по event loop-у: сначала таимер в очередь ставится - потом пуш три раза и потом макротаски триджы отрабатывают

// 1. Инициализация переменной цикла: "i" инициализирован как пустой массив: i = [].
// 2. Условие "i.length < 3" - проверяется "перед каждой итерацией" - если соответствует условию, то запускаем итерацию дальше
// (Цикл выполняется, пока длина массива "i" меньше 3)
// 3. Тело цикла -- На каждой итерации:
// 1) Вызывается setTimeout, который откладывает выполнение функции.
// 2) Время задержки вычисляется как i.length * 1000 миллисекунд.
// 3) Выполняется сначала синхронный код: пуш в "i" ("таимаут" не выполнится) - В массив "i" добавляется 1 с помощью i.push(1).
// То есть: i === 0, 1, 2 === "три итерации"
// 4. Делаем три итерации: i.length === 0 i.length === 1 i.length === 2, условие i.length < 3 не даст итерацииi.length === 2: ход,
// ОТВЕТ: триджы выведет [ 1, 1, 1 ] [ 1, 1, 1 ] [ 1, 1, 1 ], тк сначала синхронно выполнился код "пуша":
// [1,1,1,], таимаут после каждого пуша решистрируется и уходит в очередь макрозадач, потом снова пуш, второй таимаут в очередь
// макрозадач и тд - когда синхронныи код пуша выполнится то из очереди макрозадач три таимаута идут в стек и выполняются что ждали очереди
// (очередь макротасок): трижды запустился setTimeout ссылаясь на "глобал.var" === [1,1,1] и тк 3 цикла итерации то трижды [ 1, 1, 1 ] [ 1, 1, 1 ] [ 1, 1, 1 ]
for (var i = []; i.length < 3; i.push(1)) { // сначала синхронно выполнится: i.push(1)
  setTimeout(() => {
    console.log(i);
  }, i.length * 1000);
}
/*
// -----------------------------------------------------------------------------------------------------------------------------------------
for (var i = []; i.length < 3; i.push(1)) {
  setTimeout(function () {
    console.log(i.length);
  }, i.length * 1000);
}
Сначала синхронный код: [1,1,1,] - триджы запуститься функция где : i.length уже будет === 3 тк [1,1,1,]
ОТВЕТ: 3 3 3 Все функции внутри setTimeout ссылаются на актуальное состояние переменной i. К моменту их выполнения длина массива i уже равна 3.
// ----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------




// -----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------



// -----------------------------------------------------------------------------------------------------------------------------------------

 */
