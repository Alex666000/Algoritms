// Что в консоле и почему: 4 мин: https://www.youtube.com/watch?v=Z-oB7g-y3v8&list=PLIpOJPtzllpM-mzxXSF4npTEl7AE3dsa7&index=11
// Дано:
/*
const a = {a: 'a'};
const b = {b: 'b'};
const c = {};

c[a] = a;
c[b] = b;

console.log(c[a].a, c[b].b);
 */

// Ответ: undefined 'b' - ПОЯСНЕНИЕ:
// const a = { a: 'a' };
// const b = { b: 'b' };
// const c = {};
//  при использовании объектов в качестве "ключей" для "объектов, они преобразуются в СТРОКУ: "[object Object]" - обьекту "с" присвоили
//  своиство (ключ) значит: ["object Object"]
// c[a] = a; // c["object Object"] = { a: 'a' } // ниже перезаписали - то тут будет "undefined"
// c[b] = b; // c["object Object"] = { b: 'b' } - перезаписали обьект "с" по ключу ["object Object"], при обращении по ключу === 'b'
// вызов c[a].a === undefined, а вызов c[b].b = "b"
// console.log(c[a].a, c[b].b);
const a = {a: 'a'};
const b = {b: 'b'};
const c = {};
// -------> ПОДРОБНО:
// Здесь мы пытаемся использовать "объекты": "a" и "b" - в качестве КЛЮЧЕЙ для объекта "c".
// в JavaScript, при использовании объектов в качестве "ключей" для "объектов, они преобразуются в СТРОКУ: "[object Object]":
// Объект "a" автоматически преобразуется в строку через метод toString() - a.toString(); // Результат: "[object Object]"
// Поэтому фактически код становится таким: c[ "[object Object]" ] = a; то есть: В объект "c" добавляется свойство с ключом "[object Object]", значением которого является объект "a"
c[a] = a; // c[object object] = {a: 'a'}

// Точно так же объект "b" преобразуется в строку b.toString(); // Результат: "[object Object]"
// получаем: c["[object Object]"] = {b: 'b'};
c[b] = b;
// В объекте "c" ключ "[object Object]" уже существует (после предыдущей операции: c[a] = a), поэтому он перезаписывается новым
// значением, объектом "b" - После выполнения двух операций c[a] = a, c[b] = b, объект "c" выглядит так:
/*
c = {
  "[object Object]": { b: "b" } // Здесь сохранен объект `b`
}
*/
// Объект "a" в итоге теряется, потому что он был перезаписанна "b".
// вызов c[a].a === undefined, а вызов c[b].b = "b"


console.log(c[a].a, c[b].b); // Результат: undefined "b"
// изначально const c = { }
// const c = {
//   /* "[object Object]": {a: 'a'} // перезапишется  "[object Object]" на "[object Object]": {b: 'b'} после операции c[b] = b; */
//   "[object Object]": {b: 'b'}
// };

/*
Как исправить проблему?
Чтобы использовать объекты a и b в качестве ключей, нужно использовать "Map". В отличие от обычных объектов, Map позволяет использовать в качестве ключей любые значения, включая объекты.

const a = { a: "a" };
const b = { b: "b" };
const c = new Map();

c.set(a, a);
c.set(b, b);

console.log(c.get(a).a, c.get(b).b); // "a" "b"
 */

// 2 --------------------------------------------------------------------------------------------
let obj1 = { name: "Alice" };
let obj2 = { name: "Alice" };
let obj3 = obj1;

console.log(obj1 === obj2); // false, потому что obj1 и obj2 ссылаются на разные объекты
console.log(obj1 === obj3); // true, потому что obj1 и obj3 ссылаются на один и тот же объект
// --------------------------------------------------------------------------------------------
// Можем ли мы так сделать: obj.a = 2?
const obj = {
  a: 2
};

obj.a = 2;

// Ответ: Да, объект иммет ссылочный тип данных можем его изменять его своиства не смотря на const а перезаписать константу дальше в
// коде нельзя!!!

// 3 --------------------------------------------------------------------------------------------




// 4 --------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------



// --------------------------------------------------------------------------------------------


// --------------------------------------------------------------------------------------------

